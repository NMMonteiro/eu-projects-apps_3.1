import { createClient } from 'jsr:@supabase/supabase-js@2';
import { GoogleGenerativeAI } from 'npm:@google/generative-ai';

const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
};

const FUNCTION_VERSION = 'v4.0-api-integrated-manual-parse';

const getAI = () => {
    const apiKey = Deno.env.get('GEMINI_API_KEY');
    if (!apiKey) throw new Error('GEMINI_API_KEY not set');
    return new GoogleGenerativeAI(apiKey);
};

const EU_API_BASE = "https://api.tech.ec.europa.eu/search-api/prod/rest/search?apiKey=SEDIA";

async function searchWithEuApi(query: string) {
    console.log(`[searchWithEuApi] Searching for: "${query}"`);

    // Payload to find Open or Forthcoming Grants
    const payload = {
        "bool": {
            "must": [
                {
                    "terms": {
                        "type": ["1", "2", "8"] // Grants
                    }
                },
                {
                    "terms": {
                        "status": ["31094501", "31094502"] // Open, Forthcoming
                    }
                }
            ]
        }
            console.error(`[searchWithEuApi] API Error: ${res.status} ${res.statusText}`);
        const text = await res.text();
        return [{ title: "DEBUG: API Error", description: `Status: ${res.status} ${res.statusText}\nBody: ${text}`, url: "error", source: "Debug" }];
    }

    // Use .text() then parse to avoid Deno fetch body reading issues
    const text = await res.text();
    console.log(`[searchWithEuApi] Response received, length: ${text.length} chars`);

    let data;
    try {
        data = JSON.parse(text);
    } catch (parseErr: any) {
        console.error(`[searchWithEuApi] JSON Parse Error:`, parseErr);
        return [{ title: "DEBUG: Parse Error", description: `Could not parse response: ${parseErr.message}\nFirst 200 chars: ${text.substring(0, 200)}`, url: "error", source: "Debug" }];
    }

    // The API returns 'results' at the top level, not 'hits.hits'
    const results = data.results || [];
    console.log(`[searchWithEuApi] Found ${results.length} results`);

    if (results.length === 0) {
        return [{ title: "DEBUG: No Results", description: `Query: ${query}\nURL: ${url}\nPayload: ${JSON.stringify(payload)}`, url: "empty", source: "Debug" }];
    }

    // Filter for English results if possible to avoid duplicates
    // The API returns the same opportunity in multiple languages
    const englishResults = results.filter((item: any) => item.language === 'en');
    const finalResults = englishResults.length > 0 ? englishResults : results;

    return finalResults.map((item: any) => {
        try {
            return mapEuApiItemToOpportunity(item);
        } catch (err: any) {
            console.error("Mapping error for item:", JSON.stringify(item).substring(0, 200), err);
            return { title: "DEBUG: Mapping Error", description: `Error: ${err.message}`, url: "error", source: "Debug" };
        }
    });

} catch (e: any) {
    console.error('[searchWithEuApi] Failed:', e);
    return [{ title: "DEBUG: Exception", description: `Error: ${e.message}\nStack: ${e.stack}`, url: "exception", source: "Debug" }];
}
}

// Helper to map API response to our internal format
function mapEuApiItemToOpportunity(item: any) {
    // Most data is in the 'metadata' object, stored as arrays
    const md = item.metadata || {};

    // Identifier: metadata.identifier[0] or metadata.callIdentifier[0] or item.reference
    const identifier = md.identifier?.[0] || md.callIdentifier?.[0] || item.reference || "Unknown ID";

    // Title: metadata.title[0] or item.title or item.summary
    const title = md.title?.[0] || item.title || item.summary || "Untitled Opportunity";

    // Description: metadata.descriptionByte[0] or metadata.description[0] or item.summary
    let description = md.descriptionByte?.[0] || md.description?.[0] || item.summary || item.content || "No description available.";

    // Strip HTML tags for cleaner display
    description = description.replace(/<[^>]*>?/gm, '');

    // URL: item.url is usually correct, or construct from identifier
    const url = item.url || `https://ec.europa.eu/info/funding-tenders/opportunities/portal/screen/opportunities/topic-details/${identifier}`;

    // Deadline: metadata.deadlineDate[0]
    const deadline = md.deadlineDate?.[0] || "Unknown";

    // Status: metadata.status[0]
    // 31094501 = Open, 31094502 = Forthcoming, 31094503 = Closed
    const statusCode = md.status?.[0];
    let status = "Open";
    if (statusCode === "31094502") status = "Upcoming";
    if (statusCode === "31094503") status = "Closed";

    return {
        title: title,
        url: url,
        description: description.substring(0, 500) + (description.length > 500 ? "..." : ""),
        source: "EU Funding Portal (Official API)",
        status: status,
        deadline: deadline,
        budget: "See details",
        funding_entity: md.frameworkProgramme?.[0] || "EU",
        call_id: identifier,
        topic: md.destinationDescription?.[0] || "General",
        subCalls: []
    };
}

// Suggest partners based on call requirements
async function suggestPartners(callDescription: string, callEligibility: string, callTopic: string, allPartners: any[]) {
    try {
        console.log('Suggesting partners for call...');
        const ai = getAI();
        const model = ai.getGenerativeModel({
            model: 'gemini-2.0-flash-exp',
            tools: [{ googleSearch: {} }]
        });

        const prompt = `You are a consortium-building expert. Analyze this funding call and suggest the best partners from the available list.
        
        CALL DETAILS:
        Topic: ${callTopic}
        Description: ${callDescription}
        Eligibility: ${callEligibility}
        
        AVAILABLE PARTNERS:
        ${JSON.stringify(allPartners.map(p => ({
            id: p.id,
            name: p.name,
            country: p.country,
            type: p.organization_type || p.organizationType,
            description: p.description
        })))}
        
        For each partner, evaluate:
        1. Relevance to call topic and objectives
        2. Eligibility match (organization type, country)
        3. Complementary expertise and experience
        
        Return JSON array of top 5 partners (sorted by match score):
        [
            {
                "partnerId": "partner-id-from-list",
                "matchScore": 95,
                "reason": "One concise sentence explaining why they're a great fit",
                "strengths": ["AI expertise", "EU project experience", "Strong research team"]
            }
        ]
        
        Return ONLY valid JSON array.`;

        const result = await model.generateContent(prompt);
        const text = result.response.text();
        const suggestions = JSON.parse(text.replace(/```json/g, '').replace(/```/g, '').trim());

        console.log(`Generated ${suggestions.length} partner suggestions`);
        return suggestions;
    } catch (error) {
        console.error('Partner suggestion failed:', error);
        return [];
    }
}

Deno.serve(async (req) => {
    if (req.method === 'OPTIONS') {
        return new Response('ok', { headers: corsHeaders });
    }

    try {
        const body = await req.json();
        const { query, filterStatus, deepScrape, url, customSources, partnerProfile, mode, callDescription, callEligibility, callTopic, allPartners } = body;

        console.log(`[${FUNCTION_VERSION}] Request:`, { mode, query, deepScrape, url: url?.substring(0, 50) });

        // === MODE: PARTNER SUGGESTIONS ===
        if (mode === 'suggestPartners') {
            const suggestions = await suggestPartners(callDescription, callEligibility, callTopic, allPartners);
            return new Response(
                JSON.stringify({ suggestions }),
                { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
            );
        }

        // === MODE 1: DEEP ANALYSIS (Analyze a specific URL) ===
        if (deepScrape && url) {
            console.log(`[deepScrape] Analyzing: ${url}`);

            // Extract Call ID from URL if possible
            // URL format: .../topic-details/HORIZON-CL4-2024-DATA-01-03
            let callId = "";
            if (url.includes("topic-details/")) {
                const parts = url.split("topic-details/");
                if (parts.length > 1) {
                    callId = parts[1].split("?")[0].split("/")[0]; // Handle query params or trailing slashes
                }
            }

            console.log(`[deepScrape] Extracted Call ID: ${callId}`);

            let opportunityData = null;

            // 1. Try fetching details from API if we have a Call ID
            if (callId) {
                try {
                    console.log(`[deepScrape] Fetching details from API for ID: ${callId}`);
                    const apiUrl = `${EU_API_BASE}&text="${callId}"`; // Quote ID for exact match
                    const res = await fetch(apiUrl, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ "bool": { "must": [] } }) // Empty filter to get everything
                    });

                    if (res.ok) {
                        const data = await res.json();
                        const hits = data.hits?.hits || data.results || [];
                        if (hits.length > 0) {
                            // Find exact match
                            const match = hits.find((h: any) => h.identifier?.[0] === callId);
                            if (match) {
                                console.log(`[deepScrape] Found exact match in API.`);
                                opportunityData = mapEuApiItemToOpportunity(match);
                            }
                        }
                    }
                } catch (e) {
                    console.error(`[deepScrape] API fetch failed:`, e);
                }
            }

            // 2. If API failed or no ID, fall back to AI analysis (but use Google Search to be safe)
            if (!opportunityData) {
                console.log(`[deepScrape] API lookup failed/skipped. Falling back to AI with Google Search.`);
                const ai = getAI();
                const model = ai.getGenerativeModel({
                    model: 'gemini-2.0-flash-exp',
                    tools: [{ googleSearch: {} }]
                });

                const prompt = `Analyze this funding opportunity URL: ${url}
                
                Use Google Search to find the official details for this call/topic.
                
                Extract the following details into a JSON object:
                {
                    "title": "Official Title",
                    "call_id": "Call ID (e.g. HORIZON-CL4...)",
                    "description": "Summary",
                    "status": "Open/Closed",
                    "deadline": "YYYY-MM-DD",
                    "budget": "Budget",
                    "eligibility": "Eligibility",
                    "funding_entity": "Funding Body",
                    "topic": "Topic"
                }
                Return ONLY valid JSON.`;

                const result = await model.generateContent(prompt);
                const text = result.response.text();
                opportunityData = JSON.parse(text.replace(/```json/g, '').replace(/```/g, '').trim());
                opportunityData.url = url;
            }

            // 3. Partner Match Check (if profile provided)
            if (partnerProfile && opportunityData) {
                const ai = getAI();
                const model = ai.getGenerativeModel({ model: 'gemini-2.0-flash-exp' });
                const matchPrompt = `Evaluate this partner for the funding opportunity.
                
                OPPORTUNITY: ${JSON.stringify(opportunityData)}
                PARTNER: ${JSON.stringify(partnerProfile)}
                
                Return JSON:
                {
                    "score": (0-100),
                    "status": "Eligible" or "Conditional" or "Ineligible",
                    "reason": "Explanation"
                }`;

                const matchRes = await model.generateContent(matchPrompt);
                const matchData = JSON.parse(matchRes.response.text().replace(/```json/g, '').replace(/```/g, '').trim());
                opportunityData.match = matchData;
            } else if (opportunityData) {
                opportunityData.match = { score: 0, status: "Unknown", reason: "No partner selected." };
            }

            return new Response(
                JSON.stringify({ opportunity: opportunityData }),
                { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
            );
        }

        // === MODE 2: SEARCH (Find opportunities) ===
        console.log(`[search] Query: "${query}"`);
        const { useAiSearch = true } = body;

        let opportunities = [];

        // 1. Official EU API Search (Primary)
        if (useAiSearch) {
            console.log('[search] Executing EU API Search...');
            const apiResults = await searchWithEuApi(query);
            opportunities.push(...apiResults);
            console.log(`[search] EU API returned ${apiResults.length} results`);
        }

        return new Response(
            JSON.stringify({ opportunities: opportunities }),
            { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );

    } catch (error: any) {
        console.error('[ERROR]', error);
        return new Response(
            JSON.stringify({ error: error.message }),
            { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );
    }
});
